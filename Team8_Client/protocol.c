/*
 * Copyright 2016 Christopher Zell <christopher.zell@camunda.com>.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "protocol.h"


// create structures ///////////////////////////////////////////////////////////

struct Message* createMessage(struct TransportProtocol* transportProtocol, int32_t len) {
  // init message
  struct Message* message = malloc(sizeof (struct Message));
  if (message == NULL) {
    return message;
  }

  message->len = len; // htonl(len);
  message->version = 1;
  message->flags = 2;
  message->type = 0; //htons(4);
  message->streamId = 1; //htonl(1);

  //copy transport protocol message int32_to body
  message->body = transportProtocol;
  return message;
}

struct TransportProtocol* createTransportProtocol(int16_t templateId) {
  struct TransportProtocol* transportProtocol = malloc(sizeof (struct TransportProtocol));
  if (transportProtocol == NULL) {
    return NULL;
  }
  //generated by the client
  transportProtocol->protocolId = 0;
  transportProtocol->connectionId = 2562132L;
  transportProtocol->requestId = 2551312L;

  //init protocol
  transportProtocol->blockLength = 0;
  transportProtocol->templateId = templateId;
  transportProtocol->schemaId = 1;
  transportProtocol->version = 1;
  transportProtocol->resourceId = 0;
  transportProtocol->shardId = -2; //not supported yet
  return transportProtocol;
}

struct VariableData* createVariableData(const uint8_t* data) {
  struct VariableData* variableData = malloc(sizeof (struct VariableData));
  if (variableData == NULL) {
    return NULL;
  }

  if (data == NULL) {
    variableData->data = NULL;
    variableData->length = 0;
  } else {
    variableData->length = strlen(data);
    variableData->data = calloc(variableData->length, sizeof (uint8_t));
    if (variableData->data == NULL) {
      return NULL;
    }
    memcpy(variableData->data, data, variableData->length);
  }
  return variableData;
}

struct TaskCreateMessage* createTaskCreateMessage(const uint8_t* topic) {
  struct TaskCreateMessage* taskCreateMsg = malloc(sizeof (struct TaskCreateMessage));
  if (taskCreateMsg == NULL) {
    return NULL;
  }

  struct TransportProtocol* transportProtocol = createTransportProtocol(CREATE_TASK_REQUEST);
  if (transportProtocol == NULL) {
    free(taskCreateMsg);
    return NULL;
  }

  taskCreateMsg->taskType = createVariableData(topic);
  taskCreateMsg->payload = createVariableData(NULL); //not supported yet

  transportProtocol->bodyLen = TASK_CREATE_HEADER_LEN
          + taskCreateMsg->taskType->length
          + taskCreateMsg->payload->length;

  int32_t len = TRANS_HEADER_LEN + transportProtocol->bodyLen;
  taskCreateMsg->head = createMessage(transportProtocol, len);
  if (taskCreateMsg->head == NULL) {
    freeTransportProtocol(transportProtocol);
    free(taskCreateMsg);
    return NULL;
  }
  return taskCreateMsg;
}

// free structures /////////////////////////////////////////////////////////////

void freeMessage(struct Message* message) {
  if (message != NULL) {
    if (message->body != NULL) {
      freeTransportProtocol(message->body);
    }
    free(message);
  }
}

void freeTransportProtocol(struct TransportProtocol* transportProtocol) {
  free(transportProtocol);
}

void freeVariableData(struct VariableData* variableData) {
  if (variableData != NULL) {
    if (variableData->data != NULL) {
      free(variableData->data);
    }
    free(variableData);
  }
}

void freeTaskCreateMessage(struct TaskCreateMessage* taskCreateMessage) {
  if (taskCreateMessage != NULL) {
    if (taskCreateMessage->head != NULL) {
      freeMessage(taskCreateMessage->head);
    }
    if (taskCreateMessage->taskType != NULL) {
      freeVariableData(taskCreateMessage->taskType);
    }
    if (taskCreateMessage->payload != NULL) {
      freeVariableData(taskCreateMessage->payload);
    }
    free(taskCreateMessage);
  }
}

void freeSingleTaskServerAckMessage(struct SingleTaskServerAckMessage* ack) {
  if (ack != NULL) {
    freeMessage(ack->head);
    free(ack);
  }
}

void freePollAndLockTaskMessage(struct PollAndLockTaskMessage* pollAndLockTaskMessage) {
  if (pollAndLockTaskMessage != NULL) {
    if (pollAndLockTaskMessage->taskType != NULL) {
      freeVariableData(pollAndLockTaskMessage->taskType);
    }
    free(pollAndLockTaskMessage);
  }
}

// write structures ////////////////////////////////////////////////////////////

uint8_t* writeTaskCreateMessage(uint8_t* buffer, struct TaskCreateMessage* taskCreateMessage) {
  uint8_t* nextFreeBuff = writeMessage(buffer, taskCreateMessage->head);
  nextFreeBuff = writeVariableData(nextFreeBuff, taskCreateMessage->taskType);
  return writeVariableData(nextFreeBuff, taskCreateMessage->payload);
}

uint8_t* writeMessage(uint8_t* buffer, struct Message* message) {
  //message header
  uint8_t* nextFreeBuff = serialize_int32(buffer, message->len);
  nextFreeBuff = serialize_int8(nextFreeBuff, message->version);
  nextFreeBuff = serialize_int8(nextFreeBuff, message->flags);
  nextFreeBuff = serialize_int16(nextFreeBuff, message->type);
  nextFreeBuff = serialize_int32(nextFreeBuff, message->streamId);

  //body
  return writeTransportProtocol(nextFreeBuff, message->body);
}

uint8_t* writeTransportProtocol(uint8_t* buffer, struct TransportProtocol* transportProtocol) {
  //transport protocol header
  uint8_t* nextFreeBuff = serialize_int16(buffer, transportProtocol->protocolId);
  nextFreeBuff = serialize_int64(nextFreeBuff, transportProtocol->connectionId);
  nextFreeBuff = serialize_int64(nextFreeBuff, transportProtocol->requestId);
  nextFreeBuff = serialize_int16(nextFreeBuff, transportProtocol->blockLength);
  nextFreeBuff = serialize_int16(nextFreeBuff, transportProtocol->templateId);
  nextFreeBuff = serialize_int16(nextFreeBuff, transportProtocol->schemaId);
  nextFreeBuff = serialize_int16(nextFreeBuff, transportProtocol->version);
  nextFreeBuff = serialize_int16(nextFreeBuff, transportProtocol->resourceId);
  return serialize_int16(nextFreeBuff, transportProtocol->shardId);
}

uint8_t* writeVariableData(uint8_t* buffer, struct VariableData* data) {
  uint8_t* nextFreeBuff = serialize_int16(buffer, data->length);
  memcpy(nextFreeBuff, data->data, data->length);
  return nextFreeBuff + data->length;
}

void writePollAndLockTaskMessage(uint8_t* buffer, struct PollAndLockTaskMessage* pollAndLock) {
  uint8_t* nextFreeBuff = serialize_int16(buffer, pollAndLock->consumerId);
  nextFreeBuff = serialize_int64(nextFreeBuff, pollAndLock->lockTime);
  nextFreeBuff = serialize_int16(nextFreeBuff, pollAndLock->maxTasks);
  //task type
  writeVariableData(nextFreeBuff, pollAndLock->taskType);
}



// read structures /////////////////////////////////////////////////////////////

uint8_t* readMessage(uint8_t* buffer, struct Message* message) {
  //message header
  uint8_t* nextFreeBuff = deserialize_int32(buffer, &message->len);
  nextFreeBuff = deserialize_int8(nextFreeBuff, &message->version);
  nextFreeBuff = deserialize_int8(nextFreeBuff, &message->flags);
  nextFreeBuff = deserialize_int16(nextFreeBuff, &message->type);
  nextFreeBuff = deserialize_int32(nextFreeBuff, &message->streamId);

  //body
  message->body = malloc(sizeof (struct TransportProtocol));
  if (message->body == NULL) {
    return NULL;
  }
  return readTransportProtocol(nextFreeBuff, message->body);
}

uint8_t* readTransportProtocol(uint8_t* buffer, struct TransportProtocol* transportProtocol) {
  //transport protocol header
  uint8_t* nextFreeBuff = deserialize_int16(buffer, &transportProtocol->protocolId);
  nextFreeBuff = deserialize_int64(nextFreeBuff, &transportProtocol->connectionId);
  nextFreeBuff = deserialize_int64(nextFreeBuff, &transportProtocol->requestId);
  nextFreeBuff = deserialize_int16(nextFreeBuff, &transportProtocol->blockLength);
  nextFreeBuff = deserialize_int16(nextFreeBuff, &transportProtocol->templateId);
  nextFreeBuff = deserialize_int16(nextFreeBuff, &transportProtocol->schemaId);
  nextFreeBuff = deserialize_int16(nextFreeBuff, &transportProtocol->version);
  nextFreeBuff = deserialize_int16(nextFreeBuff, &transportProtocol->resourceId);
  return deserialize_int16(nextFreeBuff, &transportProtocol->shardId);
}

uint8_t* readSingleTaskServerAckMessage(uint8_t* buffer, struct SingleTaskServerAckMessage* ack) {
  ack->head = malloc(sizeof (struct Message));
  if (ack->head == NULL) {
    return NULL;
  }
  uint8_t* nextFreeBuff = readMessage(buffer, ack->head);
  return deserialize_int64(nextFreeBuff, &ack->taskId);
}
